#!/bin/sh
# shellcheck disable=SC2086
#
# Note this file uses a few commands like `tr` and `dircolors.hex` on our PATH
# to create environment variables, specifically the PATH var too. At first
# glance, this might be an issue from shells with an empty PATH. Thankfully,
# shells are smart and don't let you do this (unless you export PATH='' of
# course). For example, the following starts a shell with an empty environment,
# and prints out the environment:
#
# ```
# $ env - sh -c 'env; echo $PATH'
# PWD=/Users/andreyk
# SHLVL=1
# _=/usr/bin/env
# /usr/gnu/bin:/usr/local/bin:/bin:/usr/bin:.
# ```
#
# This "empty" shell mimics our login shell and the `sourceg` function in
# ~/.shrc too. Note how among the environment variables printed, PATH is not
# among them. However, it still has a value. Nice. The above example is from
# a macOS 1.15+ machine. With this, we're able to use common tools to generate
# our other env vars. And once we generate our PATH, we can use it further in
# the script (for things outside of system paths, like ~/bin/dircolors.hex)!
#
# To test out all the env vars available from this file, run it from an empty
# shell and source it:
#
# ```
# env - "HOME=$HOME" sh -c '. $HOME/.shenv; env' | sort
# ```
#
# Note HOME is not implicit and has to be passed. See the `sourceg` function.
#
# Further, as this file contains subshell logic to form env vars, it's not
# recommended to source this file from every child shell. As it's only for env
# vars, it's enough to just let tmux inherit the login shell's environment, and
# expose that to each tmux pane. If changes to this file are necessary, and
# restarting tmux is a bitch because you've got 10 windows open, then that's
# what the `sourceg` function in ~/.shrc is for. However, at best, you're saving
# like 30ms each time you source this directly, so ehh who cares.

########

export XDG_CONFIG_HOME="$HOME/.config"
export XDG_DATA_HOME="$HOME/.local/share"
export XDG_CACHE_HOME="$HOME/.cache"
export XDG_RUNTIME_DIR="$HOME/.run"

. ~/.config/sh/functions # for pathify

# Nix stuff
. ~/.nix-profile/etc/profile.d/nix.sh

# Go stuff
export GOBIN="$HOME/go/bin"

# Our marvelous path
PATH="$(echo "
    $(for profile in $NIX_PROFILES; do echo "$profile/bin"; done)

    $HOME/bin
    /usr/local/sbin
    /usr/local/bin
    /usr/sbin
    /usr/bin
    /sbin
    /bin

    $GOBIN
    $HOME/npm/bin

    /mnt/c/Windows/System32/WindowsPowerShell/v1.0
    /mnt/c/Windows/System32
    /mnt/c/Windows
    /mnt/c/Program Files/Git/cmd
" | pathify)"
export PATH

# Force Git to only work from our home directory
export GIT_CEILING_DIRECTORIES="$HOME"

# For macOS 1.15+; is that what being a stubborn old dude feels like?
export BASH_SILENCE_DEPRECATION_WARNING=1

# "wow he must be a really cool dude"
export VISUAL=nvim
export EDITOR="$VISUAL"

# Find our shell via $0 for dircolors. This var might be overriden by something
# else (I guess login(1) or AD on macOS), unless we run chsh.
SHELL="$(command -v bash)"
export SHELL
eval "$(dircolors.hex "$HOME/.config/dircolors/dircolors")"

# Seems like I need this if I ever ssh into this machine
export TERM=xterm-256color

# Bash-specific stuff for pretty history
export HISTSIZE=20000 # in memory
export HISTFILESIZE=20000
export HISTFILE="$HOME/.bash_history"
export HISTTIMEFORMAT="%F %T  "
export HISTCONTROL=ignoredups:erasedups
export HISTIGNORE='\:;*:'

# Miscellaneous
export INPUTRC="$HOME/.config/readline/inputrc"
export PAGER="less -R"
export TMP="${TMP:-/tmp}"
export TMPDIR="${TMPDIR:-$TMP}"

# NPM doesn't detect XDG_* vars, but at least they let us set the path
# https://github.com/npm/npm/issues/6675
# https://github.com/npm/cli/issues/654
export NPM_CONFIG_USERCONFIG="$HOME/.config/npm/npmrc"

# Shares env vars with Windows exes when we run them from within WSL. See
# https://devblogs.microsoft.com/commandline/share-environment-vars-between-wsl-and-windows
# for more deets
export WSLENV=HOME/w

# TODO use -z and return early instead
#
# also the following env vars don't work with `sourceg` because the bare shell
# sourceg uses won't have WSL_DISTRO_NAME set...
if [ -n "${WSL_DISTRO_NAME:-}" ]; then
        # HOME equivalent, but for the Windows host
        WINHOME="$(wslpath "$(wslvar USERPROFILE)")"
        export WINHOME

        # WSL_INSTANCE is the IP address of our WSL VM. We can use this IP from
        # Windows to access to services running within WSL.
        # WSL_HOST is the IP address of our Windows host. We can use this IP
        # from within WSL to access services runnig on our Windows host.
        #
        # If they're already defined, no point in doing it again since these IP
        # addresses only change when we reboot our Windows machine.

        if [ -n "$WSL_INSTANCE" ] && [ -n "$WSL_HOST" ]; then
                return
        fi

        # For this to be usable within Docker, see
        # https://www.beyondjava.net/docker-wsl-network.
        echo >&2 "Finding WSL instance IP..."
        WSLHOST="$(ip -4 addr show eth0 | awk -F'[/ ]+' '/inet/ {print $3}')"
        export WSLHOST

        # Our windows host is just the default gateway
        #
        echo >&2 "Finding Windows host..."
        WINHOST="$(ip r show default | awk '{print $3}')"
        export WINHOST
fi
